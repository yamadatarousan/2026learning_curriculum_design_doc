# Day 57: Benchmark 計測メモ

## 計測日時
2026-01-04

## 計測環境
- Go Version: 1.21+
- OS: macOS (darwin)
- CPU: 8コア（GOMAXPROCS=8）

---

## 1. IsPalindrome（回文判定）

### 改善内容
- **改善前**: 文字列を逆順にして比較（毎回新しい文字列を確保）
- **改善後**: 両端から中央に向かって比較（メモリ確保なし）

### 計測結果（予想）

```
BenchmarkIsPalindrome-8               5000000        300 ns/op       56 B/op       7 allocs/op
BenchmarkIsPalindromeOptimized-8     20000000         75 ns/op        0 B/op       0 allocs/op
```

### 改善効果
- **実行時間**: 約4倍高速化（300ns → 75ns）
- **メモリ割り当て**: ゼロ（56B → 0B）
- **割り当て回数**: ゼロ（7回 → 0回）

### 学び
- 文字列の `+=` は毎回新しいメモリを確保するため非効率
- アルゴリズムの工夫でメモリ割り当てを完全に排除できる

---

## 2. CountWords（単語カウント）

### 改善内容
- **改善前**: `strings.Fields` で分割してlen()
- **改善後**: 1文字ずつ走査してカウント

### 計測結果（予想）

```
BenchmarkCountWords/Original-8       2000000        800 ns/op      128 B/op       2 allocs/op
BenchmarkCountWords/Optimized-8      5000000        300 ns/op        0 B/op       0 allocs/op
```

### 改善効果
- **実行時間**: 約2.6倍高速化（800ns → 300ns）
- **メモリ割り当て**: ゼロ（128B → 0B）

### 学び
- 標準ライブラリは汎用的だが、特定の用途に最適化すると高速化できる
- スライスの確保が不要になるとメモリ効率が大幅に改善

---

## 3. StringConcat（文字列連結）

### 改善内容
- **Original**: `+=` で連結
- **Optimized**: `strings.Builder` を使用
- **Join**: `strings.Join` を使用

### 計測結果（予想）

```
BenchmarkStringConcat/Original-8      500000       3000 ns/op      512 B/op       5 allocs/op
BenchmarkStringConcat/Optimized-8    5000000        300 ns/op       48 B/op       1 allocs/op
BenchmarkStringConcat/Join-8         6000000        250 ns/op       32 B/op       1 allocs/op
```

### 改善効果
- **Original → Optimized**: 10倍高速化、メモリ90%削減
- **Original → Join**: 12倍高速化、メモリ93%削減

### 学び
- 文字列連結では `strings.Builder` または `strings.Join` を使う
- `+=` は絶対に避けるべき（特にループ内）
- 標準ライブラリの `strings.Join` は非常に最適化されている

---

## 4. StringConcatLarge（1000個の文字列連結）

### 改善内容
- 大量の文字列（1000個）での連結

### 計測結果（予想）

```
BenchmarkStringConcatLarge/Original-8         500      2500000 ns/op   2097152 B/op    1000 allocs/op
BenchmarkStringConcatLarge/Optimized-8     100000        12000 ns/op      8192 B/op       5 allocs/op
BenchmarkStringConcatLarge/Join-8          200000         6000 ns/op      4096 B/op       1 allocs/op
```

### 改善効果
- **Original → Optimized**: 約200倍高速化
- **Original → Join**: 約400倍高速化
- **メモリ使用量**: 99%削減

### 学び
- データサイズが大きくなると、最適化の効果が劇的に増加
- O(n²) と O(n) の差が顕著に現れる

---

## 5. FindMax（最大値探索）

### 改善内容
- **改善前**: バブルソートで並べ替えてから最大値を取得（O(n²)）
- **改善後**: 1回走査で最大値を見つける（O(n)）

### 計測結果（予想）

```
BenchmarkFindMax/Original-8         500000       3000 ns/op      160 B/op       2 allocs/op
BenchmarkFindMax/Optimized-8      10000000        120 ns/op        0 B/op       0 allocs/op
```

### 改善効果
- **実行時間**: 約25倍高速化（3000ns → 120ns）
- **メモリ割り当て**: ゼロ

### 学び
- アルゴリズムの計算量が最も重要
- 不要なソートを避ける

---

## 6. FindMaxLarge（1000個の数値で最大値探索）

### 改善内容
- データサイズを1000個に増やした場合

### 計測結果（予想）

```
BenchmarkFindMaxLarge/Original-8           10      100000000 ns/op   8192 B/op       1 allocs/op
BenchmarkFindMaxLarge/Optimized-8      500000           2500 ns/op      0 B/op       0 allocs/op
```

### 改善効果
- **実行時間**: 約40000倍高速化（100ms → 2.5μs）
- **計算量の差**: O(n²) vs O(n) が明確

### 学び
- データサイズが大きくなると、計算量の違いが極端に現れる
- n=10: 25倍、n=1000: 40000倍の差

---

## パフォーマンス改善のパターン（まとめ）

### パターン1: 文字列連結
- **問題**: `+=` は遅い
- **解決**: `strings.Builder` または `strings.Join`
- **効果**: 10倍〜400倍高速化

### パターン2: 不要なメモリ割り当て
- **問題**: スライス/文字列の頻繁な確保
- **解決**: 事前確保、または割り当てを避ける実装
- **効果**: メモリ使用量90%削減、GC負荷軽減

### パターン3: アルゴリズムの計算量
- **問題**: O(n²) のアルゴリズム
- **解決**: O(n) または O(log n) のアルゴリズム
- **効果**: データサイズに応じて100倍〜10000倍高速化

### パターン4: 標準ライブラリの活用
- **問題**: 自前実装が非効率
- **解決**: 標準ライブラリの最適化された関数を使う
- **効果**: 開発時間短縮 + パフォーマンス向上

---

## ベンチマークから学んだこと

### 1. 推測ではなく計測
- 「このコードは遅いはず」という推測は当てにならない
- 実際に計測すると意外な結果が出ることも多い

### 2. 小さな改善の積み重ね
- 1つ1つは小さな改善でも、積み重なると大きな効果
- 特にループ内の処理は影響が大きい

### 3. メモリ割り当ての重要性
- 実行時間だけでなく、メモリ使用量も重要
- GCの負荷を減らすことで、長時間稼働するサーバーのパフォーマンスが安定

### 4. データサイズによる違い
- 小さいデータでは差が小さいことも
- 実際の使用例に近いサイズでベンチマークを取る

### 5. 正しさが最優先
- パフォーマンスより機能の正しさが重要
- 通常のテストで正しさを保証してから最適化

---

## 次のアクションアイテム

### 実務で活用する

1. **パフォーマンスが重要な箇所にベンチマークを追加**
   - APIのホットパス
   - データ処理のループ
   - 暗号化/シリアライズ

2. **CI/CDでベンチマークを自動実行**
   - PR毎にベンチマークを実行
   - パフォーマンス劣化を早期検出

3. **リファクタリング時の検証**
   - 変更前後でベンチマークを比較
   - 意図しないパフォーマンス劣化を防ぐ

### さらに学ぶ

1. **プロファイリング**
   - `pprof` でボトルネックを特定
   - CPU プロファイル、メモリプロファイル

2. **並列処理のベンチマーク**
   - `b.RunParallel` で並行処理のパフォーマンスを計測

3. **データサイズのバリエーション**
   - 様々なサイズでベンチマークを取る
   - 最適なアルゴリズムの選択

---

## 実際のベンチマーク結果（記入欄）

※動作確認時に実際の結果をここに記録してください

```
# 実行コマンド
go test -bench=. -benchmem

# 結果
（ここに実際の結果を貼り付け）
```

---

**最終更新**: 2026-01-04
