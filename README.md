# Go TODO API Server

これは、30日間のGo言語学習カリキュラムの成果物として作成された、シンプルなTODOリストAPIサーバーです。

このアプリケーションは、Goの標準ライブラリといくつかの一般的な外部ライブラリを使用して、完全なCRUD（作成、読み取り、更新、削除）機能を提供します。データはSQLiteデータベースに永続的に保存されます。

## 機能

- TODOアイテムの作成 (Create)
- TODOアイテムのリスト取得 (Read)
- TODOアイテムの更新 (Update)
- TODOアイテムの削除 (Delete)

## 要件

- Go (バージョン 1.18 以上を推奨)

## 実行方法

1.  **依存関係のインストール:**
    プロジェクトのルートディレクトリで以下のコマンドを実行し、必要なライブラリをインストールします。
    ```bash
    go mod tidy
    ```

2.  **サーバーの起動:**
    `day30` ディレクトリ（あるいは `main.go` があるディレクトリ）に移動し、以下のコマンドを実行します。
    ```bash
    go run .
    ```
    サーバーが `http://localhost:8080` で起動します。

## API仕様

### 1. TODOリストの取得

- **エンドポイント:** `GET /todos`
- **説明:** すべてのTODOアイテムのリストをJSON形式で返します。
- **成功レスポンス (200 OK):**
  ```json
  [
    {
      "id": 1,
      "name": "Learn Go"
    },
    {
      "id": 2,
      "name": "Write a README"
    }
  ]
  ```

### 2. TODOの新規作成

- **エンドポイント:** `POST /todos`
- **説明:** 新しいTODOアイテムを作成します。
- **リクエストボディ:**
  ```json
  {
    "name": "My New Todo"
  }
  ```
- **成功レスポンス (201 Created):**
  ```json
  {
    "id": 3,
    "name": "My New Todo"
  }
  ```

### 3. TODOの更新

- **エンドポイント:** `PUT /todos/{id}`
- **説明:** 指定したIDのTODOアイテムの名前を更新します。
- **リクエストボディ:**
  ```json
  {
    "name": "My Updated Todo Name"
  }
  ```
- **成功レスポンス (200 OK):**
  ```
  Todo updated successfully
  ```

### 4. TODOの削除

- **エンドポイント:** `DELETE /todos/{id}`
- **説明:** 指定したIDのTODOアイテムを削除します。
- **成功レスポンス (204 No Content):**
  (レスポンスボディなし)

---

### 採用フレームワーク

本プロジェクトでは、Webフレームワークとして **Gin** を採用します。

#### 選定理由

1.  **利用者の多さと情報の豊富さ:**
    GoのWebフレームワークとしてデファクトスタンダードに近く、日本語・英語を問わずドキュメントや技術記事が豊富です。これにより、学習や開発で問題が発生した際に、迅速に解決策を見つけられる可能性が高いと判断しました。

2.  **実績とエコシステムの充実:**
    多くの商用プロジェクトで採用実績があり、安定性が期待できます。また、ロギング、認証、監視など、様々な用途のミドルウェアがエコシステムとして充実しており、効率的な開発が可能です。

3.  **キャリアへの接続性:**
    Goを採用している多くの企業でGinが利用されているため、このスキルを習得することは、将来的に仕事へ繋がる可能性を高めるための実践的な選択だと考えています。

---

## データベース運用手順

このプロジェクトでは、データベースとして **PostgreSQL** を、スキーマ管理ツールとして **golang-migrate/migrate** を使用します。

### 1. 初回セットアップ

1.  **ツールのインストール (macOSの場合):**
    ```bash
    brew install golang-migrate
    ```

2.  **データベースの起動:**
    プロジェクトのルートディレクトリでDockerコンテナを起動します。
    ```bash
    docker-compose up -d
    ```

### 2. マイグレーション操作

マイグレーションコマンドは、プロジェクトのルートディレクトリで実行します。

-   **最新バージョンまで適用する (`up`)**
    未適用のマイグレーションをすべて実行し、データベースを最新の状態にします。
    ```bash
    migrate -database "postgres://user:password@localhost:5433/todo_db?sslmode=disable" -path go/db/migrations up
    ```

-   **1つ前のバージョンに戻す (`down`)**
    最後に適用したマイグレーションを1つだけ取り消します。
    ```bash
    migrate -database "postgres://user:password@localhost:5433/todo_db?sslmode=disable" -path go/db/migrations down 1
    ```

-   **現在のバージョンを確認する (`version`)**
    現在データベースに適用されているマイグレーションのバージョンを確認します。
    ```bash
    migrate -database "postgres://user:password@localhost:5433/todo_db?sslmode=disable" -path go/db/migrations version
    ```

-   **新しいマイグレーションファイルを作成する**
    スキーマを変更する際は、以下のコマンドで新しい`up`/`down`ファイルを作成します。
    ```bash
    migrate create -ext sql -dir go/db/migrations -seq [変更内容の短い説明]
    ```
    例: `migrate create -ext sql -dir go/db/migrations -seq add_user_table`

-   **`dirty`状態の修正（緊急時）**
    マイグレーションが途中で失敗すると、データベースが`dirty`状態になることがあります。その際は、`force`コマンドで特定のクリーンなバージョンに強制的に設定し直します。
    ```bash
    # 例: バージョン3の状態に強制的に戻す
    migrate -database "postgres://user:password@localhost:5433/todo_db?sslmode=disable" -path go/db/migrations force 3
    ```

### 3. データベースへの直接接続

`psql`を使い、コンテナ内のデータベースに直接接続してデータを参照・操作できます。

```bash
docker-compose exec db psql -U user -d todo_db
```
- `\dt`: テーブル一覧を表示
- `SELECT * FROM todos;`: `todos`テーブルの内容を表示
- `\q`: `psql`を終了

---

## 認証方式

本APIでは、認証方式として **JWT (JSON Web Token) ベースのトークン認証** を採用します。

### 選定理由

認証方式には、古くから利用されているCookieベースのセッション認証と、近年APIで主流となっているJWTベースのトークン認証があります。それぞれの特徴を比較した上で、今回はJWTを選択しました。

1.  **ステートレスであること**
    -   JWTは、サーバー側でセッション情報（状態）を保持する必要がありません。リクエストに含まれるトークン自体を検証するだけで認証が完結します。
    -   これにより、サーバーの負荷が軽減され、複数台のサーバーへスケールアウト（負荷分散）することが容易になります。

2.  **クライアントの多様性への対応**
    -   Cookieは主にブラウザでの利用を前提としていますが、JWTはHTTPヘッダーに含めるのが一般的なため、Webフロントエンド、スマートフォンアプリ、サーバー間通信など、クライアントの種類を問いません。
    -   将来的に様々なクライアントから利用される可能性を考慮し、汎用性の高いJWTが適していると判断しました。

3.  **情報の内包**
    -   JWTのペイロード（中身）には、ユーザーIDや権限といった情報を含めることができます。
    -   これにより、認証後のリクエストでユーザー情報を取得するためにデータベースへ問い合わせる回数を減らせる可能性があります。

これらの理由から、本APIの認証方式としてJWTを採用します。
